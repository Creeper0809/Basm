# Basm Stage1 문법(현재 구현 기준)

이 문서는 **현재 레포의 Stage1 컴파일러가 실제로 처리할 수 있는 문법**을 기준으로 정리했습니다.
> 핵심 컨셉: **High-Level Assembly**
> - 레지스터를 숨기지 않고 직접 다룸
> - 문장은 거의 1:1로 NASM 코드로 내려감
> - Stage1은 아직 “표현식 언어”라기보다 “문장 언어”에 가까움

---

## 1) 어휘 규칙(토큰)

### 공백/줄바꿈
- 공백/탭/개행은 토큰 구분에만 사용됩니다.

### 주석
- 한 줄 주석만 지원합니다.
- `//` 부터 줄 끝까지가 주석입니다.

```c
rax += 1; // 여기부터 끝까지 주석
```

### 키워드
- `func`, `var`, `if`, `ptr8`, `ptr64`

### 식별자(ident)
- 함수 이름, 변수 이름(전역/로컬)로 사용됩니다.

### 레지스터(reg)
현재 Stage1에서 “레지스터 토큰”으로 인식되는 이름은 아래뿐입니다.

- 64-bit: `rax rbx rcx rdx rsi rdi rsp rbp`
- 64-bit: `r8 r9 r10 r11 r12 r13 r14 r15`

> `eax` 같은 32-bit 레지스터 이름은 아직 **현재 문법에서 레지스터로 인식되지 않습니다.**

### 정수 리터럴(int)
- 10진수: `123`
- 16진수: `0x1122`, `0XFF`

> `-1` 같은 음수 리터럴은 별도 문법이 없습니다. 필요하면 `rax = 0; rax -= 1;` 같은 방식으로 만듭니다.

### 문자열 리터럴(str)
- 큰따옴표: `"..."`
- 지원 escape: `\n`, `\t`, `\"`, `\\`
- 문자열 내부에 “raw newline(실제 개행)”은 허용되지 않습니다.

---

## 2) 프로그램 구조

### 전체 구조
- 전역 `var` 선언(0개 이상)
- 함수 `func` 선언(0개 이상)
- 반드시 `func main() { ... }` 가 존재해야 합니다.

대략적인 형태:

```c
var g;
var buf[16];

func main() {
    var x;
    // ...
}
```

---

## 3) 전역 변수 선언

### 스칼라 전역
```c
var g_qword;
```
- 8바이트(qword) 슬롯을 하나 잡고 0으로 초기화됩니다.

### 전역 배열(바이트 배열)
```c
var g_bytes[4];
```
- N 바이트짜리 raw 메모리 블록입니다.
- 초기화는 없습니다(.bss `resb` 개념).

---

## 4) 함수 선언

### 기본 형태
```c
func foo() {
    // ...
}
```

### 인자 목록
```c
func f(a, b, c) { }
```
- 선언부 인자는 `ident`를 콤마로 나열하며 최대 6개까지 파싱됩니다.
- **Stage1에서는 선언된 인자를 실제로 로컬 변수로 바인딩/접근하는 기능이 아직 없습니다.**

### 함수 바디 규칙(First Statement Rule)
- 함수 바디 시작 부분에는 `var` 로컬 선언이 0개 이상 올 수 있습니다.
- `var` 선언이 끝나면 그 다음부터는 statement만 올 수 있습니다.
  - 즉, 중간에 `var`를 다시 선언하는 형태는 허용되지 않습니다.

---

## 5) 로컬 변수 선언

### 로컬 스칼라(8바이트)
```c
func main() {
    var x;
    // ...
}
```
- 8바이트 슬롯이 스택에 잡히며 기본값은 0입니다.

### 로컬 배열(바이트 배열)
```c
func main() {
    var buf[16];
}
```
- 스택에 **raw 바이트 버퍼**가 잡힙니다.
- 배열은 초기화하지 않습니다.
- 스택 할당은 8바이트 단위로 올림(round-up)됩니다.
- 함수 전체 로컬 할당량을 16바이트 정렬 유지하도록 padding이 들어갈 수 있습니다.

---

## 6) addr과 ptr 접근

Stage1에서 메모리 접근은 `ptr8[...]`, `ptr64[...]` 형태로만 합니다.

### addr 문법
`ptr*[addr]`의 `addr`는 아래 중 하나입니다.

- `ident`
- `ident + reg`  (reg는 **바이트 오프셋**)
- `reg`
- `reg + int`
- `reg - int`

> **스케일 문법은 없습니다.**
> 예를 들어 qword 배열처럼 “index*8”이 필요하면, 사용자가 직접 `rax = 8;` 같은 바이트 오프셋을 만들어야 합니다.

### load
- `reg = ptr8[addr];`
- `reg = ptr64[addr];`

예:
```c
rdi = ptr8[g_bytes + rax];
rax = ptr64[g_qwords + rax];
```

### store
- `ptr8[addr] = (reg | int);`
- `ptr64[addr] = reg;`
- `ptr64[addr] = int;` 는 **signed 32-bit 범위에서만 허용**됩니다.

중요: x86-64는 `mov qword [mem], imm64` 인코딩이 없어서, 큰 64비트 상수는 아래처럼 해야 합니다.

```c
r11 = 0x1122334455667788;
ptr64[qw + rax] = r11;
```

---

## 7) 문장

Stage1은 “표현식 우선순위” 같은 것을 거의 지원하지 않고, 아래 문장들만 지원합니다.

### 7.1 레지스터 대입(=)
```c
rax = 123;
rax = rbx;
rax = ptr8[buf + rdx];
rax = ptr64[g_qword];
```
- RHS는 `int | reg | ptr8[...] | ptr64[...]` 중 하나만 올 수 있습니다.
- `rax = rbx + 1;` 같은 일반 표현식은 **현재 불가**입니다.

### 7.2 복합 대입
레지스터에만 적용됩니다:

- `+=`, `-=`, `*=`
- `&=`, `|=`, `^=`
- `<<=`, `>>=`

예:
```c
rbx += 5;
rbx &= 0xFF;
rcx <<= 6;
```

제약:
- `<<=` / `>>=` 의 RHS는 현재 **int(즉시값)만 허용**됩니다.

### 7.3 함수 호출 문장
형태:
```c
ident '(' [args] ')' ';'
```
- 인자는 최대 6개
- 인자 타입: `int | reg | str | ptr8[...] | ptr64[...]`

예:
```c
print_str("hello\n");
print_dec(rdi);
```

주의:
- 호출은 일반적으로 caller-saved 레지스터를 많이 clobber 합니다.
  - 예제처럼, “값을 레지스터에 들고 print_* 호출을 여러 번” 할 때는 중간에 값이 깨질 수 있으니 다시 로드하거나(또는 callee-saved 사용) 주의해야 합니다.

---

## 8) if 문 (비교 연산은 여기서만 가능)

### 문법
```c
if ( <reg> <cmp> <int|reg> ) { <stmt>* }
```

- `<cmp>`: `== != < <= > >=`
- 비교 연산은 **if 조건에서만 허용**됩니다.
- `else`는 없습니다.

예:
```c
if (rbx >= 16) {
    r11 = 1;
}

// pseudo-else는 두 개의 if로 작성
r11 = 0;
if (rbx < 64)  { r11 = 111; }
if (rbx >= 64) { r11 = 222; }
```

주의:
- Stage1 비교는 CPU의 signed 조건 점프(jl/jg 계열)를 기반으로 합니다.
  - unsigned 비교가 필요하면 Stage2에서 확장하거나 별도 규칙이 필요합니다.

---

## 9) 한 파일로 기능 확인하기

현재 구현된 대부분의 기능은 [examples/hello.b](/examples/hello.b)에서 한 번에 볼 수 있습니다.

---

## 10) 현재 Stage1의 의도적인 제한

- 일반 수식/표현식 없음(문장 기반)
- 비교 연산은 `if` 조건에서만
- shift RHS는 즉시값만
- `ptr64[mem] = imm64` 직접 저장 불가(큰 상수는 reg 경유)
- 함수 인자(선언)는 파싱만 하고 아직 사용 불가
- 주석은 `//` 한 줄 주석만
